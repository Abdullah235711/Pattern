<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>3x3 Pattern Drawer</title>
  <style>
    body{font-family: Arial; display:flex; flex-direction:column; align-items:center; padding:16px;}
    canvas{border:1px solid #aaa; touch-action:none;}
    .controls{margin-top:10px;}
    button{padding:8px 12px; margin-right:8px;}
    .hint{font-size:13px; color:#555; margin-top:8px;}
    #patternText{margin-top:10px; font-size:16px; font-weight:bold; color:#222;}
  </style>
</head>
<body>
  <h3>3×3 Pattern Drawer</h3>
  <canvas id="c" width="360" height="360"></canvas>
  <div class="controls">
    <button id="clear">Clear</button>
    <button id="copy">Copy Pattern as Text</button>
  </div>
  <div class="hint">
    Dots are numbered like this:<br>
    1&nbsp;&nbsp;2&nbsp;&nbsp;3<br>
    4&nbsp;&nbsp;5&nbsp;&nbsp;6<br>
    7&nbsp;&nbsp;8&nbsp;&nbsp;9
  </div>
  <div id="patternText">Pattern: </div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const size = canvas.width;
const padding = 60;
const grid = 3;
const step = (size - padding*2) / (grid - 1);
const dots = [];
let drawing=false;
let lastPos=null;
let path=[];

// make dots positions
for(let r=0;r<grid;r++){
  for(let c=0;c<grid;c++){
    dots.push({x: padding + c*step, y: padding + r*step, id: r*grid + c + 1}); // id is 1–9
  }
}

function drawBoard(){
  ctx.clearRect(0,0,size,size);
  // draw existing path lines
  ctx.lineWidth = 8;
  ctx.lineCap = 'round';
  ctx.strokeStyle = '#000';
  if(path.length>0){
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for(let i=1;i<path.length;i++){
      ctx.lineTo(path[i].x, path[i].y);
    }
    if(drawing && lastPos){
      ctx.lineTo(lastPos.x, lastPos.y);
    }
    ctx.stroke();
  }

  // draw dots
  for(const d of dots){
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.arc(d.x, d.y, 18, 0, Math.PI*2);
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#333';
    ctx.stroke();

    // small inner circle if selected at least once
    if(path.find(p=>p.id===d.id)){
      ctx.beginPath();
      ctx.fillStyle = '#333';
      ctx.arc(d.x, d.y, 8, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // update pattern text
  document.getElementById("patternText").innerText = "Pattern: " + path.map(p=>p.id).join('');
}

function getPointerPos(e){
  const rect = canvas.getBoundingClientRect();
  const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
  const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
  return {x: clientX - rect.left, y: clientY - rect.top};
}

function nearestDot(pos){
  for(const d of dots){
    const dx = pos.x - d.x, dy = pos.y - d.y;
    if(Math.hypot(dx,dy) <= 26) return d;
  }
  return null;
}

canvas.addEventListener('pointerdown', e=>{
  drawing=true;
  lastPos = getPointerPos(e);
  const nd = nearestDot(lastPos);
  if(nd){
    const last = path[path.length - 1];
    if(!last || last.id !== nd.id){ // avoid duplicates
      path.push(nd);
    }
  }
  drawBoard();
  e.preventDefault();
});

canvas.addEventListener('pointermove', e=>{
  if(!drawing) return;
  lastPos = getPointerPos(e);
  const nd = nearestDot(lastPos);
  if(nd){
    const last = path[path.length - 1];
    if(!last || last.id !== nd.id){ // avoid duplicates
      path.push(nd);
    }
  }
  drawBoard();
  e.preventDefault();
});

window.addEventListener('pointerup', e=>{
  drawing=false;
  lastPos=null;
  drawBoard();
});

document.getElementById('clear').addEventListener('click', ()=>{
  path=[];
  drawBoard();
});

document.getElementById('copy').addEventListener('click', ()=>{
  const seq = path.map(p=>p.id).join('');
  if(seq.length === 0){
    alert("No pattern drawn yet!");
    return;
  }
  navigator.clipboard.writeText(seq).then(()=>{
    alert("Pattern copied: " + seq);
  });
});

// initial draw
drawBoard();
</script>
</body>
</html><!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>3x3 Pattern Drawer</title>
  <style>
    body{font-family: Arial; display:flex; flex-direction:column; align-items:center; padding:16px;}
    canvas{border:1px solid #aaa; touch-action:none;}
    .controls{margin-top:10px;}
    button{padding:8px 12px; margin-right:8px;}
    .hint{font-size:13px; color:#555; margin-top:8px;}
    #patternText{margin-top:10px; font-size:16px; font-weight:bold; color:#222;}
  </style>
</head>
<body>
  <h3>3×3 Pattern Drawer</h3>
  <canvas id="c" width="360" height="360"></canvas>
  <div class="controls">
    <button id="clear">Clear</button>
    <button id="copy">Copy Pattern as Text</button>
  </div>
  <div class="hint">
    Dots are numbered like this:<br>
    1&nbsp;&nbsp;2&nbsp;&nbsp;3<br>
    4&nbsp;&nbsp;5&nbsp;&nbsp;6<br>
    7&nbsp;&nbsp;8&nbsp;&nbsp;9
  </div>
  <div id="patternText">Pattern: </div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const size = canvas.width;
const padding = 60;
const grid = 3;
const step = (size - padding*2) / (grid - 1);
const dots = [];
let drawing=false;
let lastPos=null;
let path=[];

// make dots positions
for(let r=0;r<grid;r++){
  for(let c=0;c<grid;c++){
    dots.push({x: padding + c*step, y: padding + r*step, id: r*grid + c + 1}); // id is 1–9
  }
}

function drawBoard(){
  ctx.clearRect(0,0,size,size);
  // draw existing path lines
  ctx.lineWidth = 8;
  ctx.lineCap = 'round';
  ctx.strokeStyle = '#000';
  if(path.length>0){
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for(let i=1;i<path.length;i++){
      ctx.lineTo(path[i].x, path[i].y);
    }
    if(drawing && lastPos){
      ctx.lineTo(lastPos.x, lastPos.y);
    }
    ctx.stroke();
  }

  // draw dots
  for(const d of dots){
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.arc(d.x, d.y, 18, 0, Math.PI*2);
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#333';
    ctx.stroke();

    // small inner circle if selected at least once
    if(path.find(p=>p.id===d.id)){
      ctx.beginPath();
      ctx.fillStyle = '#333';
      ctx.arc(d.x, d.y, 8, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // update pattern text
  document.getElementById("patternText").innerText = "Pattern: " + path.map(p=>p.id).join('');
}

function getPointerPos(e){
  const rect = canvas.getBoundingClientRect();
  const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
  const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
  return {x: clientX - rect.left, y: clientY - rect.top};
}

function nearestDot(pos){
  for(const d of dots){
    const dx = pos.x - d.x, dy = pos.y - d.y;
    if(Math.hypot(dx,dy) <= 26) return d;
  }
  return null;
}

canvas.addEventListener('pointerdown', e=>{
  drawing=true;
  lastPos = getPointerPos(e);
  const nd = nearestDot(lastPos);
  if(nd){
    const last = path[path.length - 1];
    if(!last || last.id !== nd.id){ // avoid duplicates
      path.push(nd);
    }
  }
  drawBoard();
  e.preventDefault();
});

canvas.addEventListener('pointermove', e=>{
  if(!drawing) return;
  lastPos = getPointerPos(e);
  const nd = nearestDot(lastPos);
  if(nd){
    const last = path[path.length - 1];
    if(!last || last.id !== nd.id){ // avoid duplicates
      path.push(nd);
    }
  }
  drawBoard();
  e.preventDefault();
});

window.addEventListener('pointerup', e=>{
  drawing=false;
  lastPos=null;
  drawBoard();
});

document.getElementById('clear').addEventListener('click', ()=>{
  path=[];
  drawBoard();
});

document.getElementById('copy').addEventListener('click', ()=>{
  const seq = path.map(p=>p.id).join('');
  if(seq.length === 0){
    alert("No pattern drawn yet!");
    return;
  }
  navigator.clipboard.writeText(seq).then(()=>{
    alert("Pattern copied: " + seq);
  });
});

// initial draw
drawBoard();
</script>
</body>
  </html><!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>3x3 Pattern Drawer</title>
  <style>
    body{font-family: Arial; display:flex; flex-direction:column; align-items:center; padding:16px;}
    canvas{border:1px solid #aaa; touch-action:none;}
    .controls{margin-top:10px;}
    button{padding:8px 12px; margin-right:8px;}
    .hint{font-size:13px; color:#555; margin-top:8px;}
    #patternText{margin-top:10px; font-size:16px; font-weight:bold; color:#222;}
  </style>
</head>
<body>
  <h3>3×3 Pattern Drawer</h3>
  <canvas id="c" width="360" height="360"></canvas>
  <div class="controls">
    <button id="clear">Clear</button>
    <button id="copy">Copy Pattern as Text</button>
  </div>
  <div class="hint">
    Dots are numbered like this:<br>
    1&nbsp;&nbsp;2&nbsp;&nbsp;3<br>
    4&nbsp;&nbsp;5&nbsp;&nbsp;6<br>
    7&nbsp;&nbsp;8&nbsp;&nbsp;9
  </div>
  <div id="patternText">Pattern: </div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const size = canvas.width;
const padding = 60;
const grid = 3;
const step = (size - padding*2) / (grid - 1);
const dots = [];
let drawing=false;
let lastPos=null;
let path=[];

// make dots positions
for(let r=0;r<grid;r++){
  for(let c=0;c<grid;c++){
    dots.push({x: padding + c*step, y: padding + r*step, id: r*grid + c + 1}); // id is 1–9
  }
}

function drawBoard(){
  ctx.clearRect(0,0,size,size);
  // draw existing path lines
  ctx.lineWidth = 8;
  ctx.lineCap = 'round';
  ctx.strokeStyle = '#000';
  if(path.length>0){
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for(let i=1;i<path.length;i++){
      ctx.lineTo(path[i].x, path[i].y);
    }
    if(drawing && lastPos){
      ctx.lineTo(lastPos.x, lastPos.y);
    }
    ctx.stroke();
  }

  // draw dots
  for(const d of dots){
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.arc(d.x, d.y, 18, 0, Math.PI*2);
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#333';
    ctx.stroke();

    // small inner circle if selected at least once
    if(path.find(p=>p.id===d.id)){
      ctx.beginPath();
      ctx.fillStyle = '#333';
      ctx.arc(d.x, d.y, 8, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // update pattern text
  document.getElementById("patternText").innerText = "Pattern: " + path.map(p=>p.id).join('');
}

function getPointerPos(e){
  const rect = canvas.getBoundingClientRect();
  const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
  const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
  return {x: clientX - rect.left, y: clientY - rect.top};
}

function nearestDot(pos){
  for(const d of dots){
    const dx = pos.x - d.x, dy = pos.y - d.y;
    if(Math.hypot(dx,dy) <= 26) return d;
  }
  return null;
}

canvas.addEventListener('pointerdown', e=>{
  drawing=true;
  lastPos = getPointerPos(e);
  const nd = nearestDot(lastPos);
  if(nd){
    const last = path[path.length - 1];
    if(!last || last.id !== nd.id){ // avoid duplicates
      path.push(nd);
    }
  }
  drawBoard();
  e.preventDefault();
});

canvas.addEventListener('pointermove', e=>{
  if(!drawing) return;
  lastPos = getPointerPos(e);
  const nd = nearestDot(lastPos);
  if(nd){
    const last = path[path.length - 1];
    if(!last || last.id !== nd.id){ // avoid duplicates
      path.push(nd);
    }
  }
  drawBoard();
  e.preventDefault();
});

window.addEventListener('pointerup', e=>{
  drawing=false;
  lastPos=null;
  drawBoard();
});

document.getElementById('clear').addEventListener('click', ()=>{
  path=[];
  drawBoard();
});

document.getElementById('copy').addEventListener('click', ()=>{
  const seq = path.map(p=>p.id).join('');
  if(seq.length === 0){
    alert("No pattern drawn yet!");
    return;
  }
  navigator.clipboard.writeText(seq).then(()=>{
    alert("Pattern copied: " + seq);
  });
});

// initial draw
drawBoard();
</script>
</body>
  </html>
